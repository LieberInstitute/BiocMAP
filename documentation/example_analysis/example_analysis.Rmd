---
title: "Example Analysis using BiocMAP Output Objects"
author: 
  - name: Nicholas J. Eagles
    affiliation:
    - &libd Lieber Institute for Brain Development, Johns Hopkins Medical Campus
    email: nickeagles77@gmail.com
  - name: Leonardo Collado-Torres
    affiliation:
    - *libd
    - &ccb Center for Computational Biology, Johns Hopkins University
    email: lcolladotor@gmail.com
output:
  BiocStyle::pdf_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
---

```{r vignette_setup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()

## Bib setup
library("RefManageR")

## Write bibliography information
bib <- c(
    R = citation(),
    bsseq = citation("bsseq"),
    BiocStyle = citation("BiocStyle")[1],
    DelayedArray = citation("DelayedArray"),
    ggplot2 = citation("ggplot2"),
    HDF5Array = citation("HDF5Array"),
    knitr = citation("knitr")[1],
    RefManageR = citation("RefManageR")[1],
    rmarkdown = citation("rmarkdown")[1],
    sessioninfo = citation("sessioninfo")[1]
)
```

# Add Experiment Metadata to BiocMAP Outputs

The `bsseq` output objects from BiocMAP contain methylation and coverage info for our samples in the dataset. However, we're interested in exploring how this information relates back to sample metadata and phenotype information, present in an external file. Our first step will therefore be to load the BiocMAP output objects into memory, and manually attach the additional sample metadata to each object.

```{r, "load_packages", message = FALSE}
#  Load required R packages
library("bsseq")
library("HDF5Array")
library("ggplot2")

#  Path to the sample metadata and BiocMAP outputs. The outputs are too large
#  to host in this repository, so we reference local paths here
meta_file <- file.path(
    "/dcl02/lieber/ajaffe/FlowRNA_RNAseq/WGBS",
    "FlowRNA_WGBS_Sample_Information_with_Pheno_Info.csv"
)
out_dir <- file.path(
    "/dcs04/lieber/lcolladotor/flowRNA_LIBD001/flowRNA_WGBS/processed-data",
    "03_BiocMAP/BiocMAP_output"
)
```

```{r setup, include = FALSE}
#   Only run the analysis when the BiocMAP files exist locally
knitr::opts_chunk$set(eval = dir.exists(out_dir))
```

```{r, "load_objects"}
#  Load the 'CpG'-context object
bs_cpg <- loadHDF5SummarizedExperiment(
    file.path(out_dir, "BSobjects", "objects", "combined"),
    prefix = "CpG"
)

#  Load the 'CpH'-context object. Note: this requires quite a bit of memory
#  (~23GB) even though the assays are disk-backed!
bs_cph <- loadHDF5SummarizedExperiment(
    file.path(out_dir, "BSobjects", "objects", "combined"),
    prefix = "CpH"
)

#  Read in experiment-specific metadata and ensure sample ID orders match
meta <- read.csv(meta_file)
meta <- meta[match(colnames(bs_cpg), meta$LIBD.), ]

#  Add this metadata to the Bioconductor objects
colData(bs_cpg) <- cbind(colData(bs_cpg), meta)
colData(bs_cph) <- cbind(colData(bs_cph), meta)

#  Keep a copy of the metadata as a data frame, for easy plotting
meta_df <- data.frame(colData(bs_cpg))
```

# Exploratory Plots

## Bisulfite-Conversion Efficiency by Cell Population

This experiment used spike-ins of the lambda bacteriophage genome, which were quantified via BiocMAP to infer bisulfite-conversion rate. Successful bisulfite conversion is a pre-requisite for accurate methylation calls, so we'd like to see both that values are close to 1, and that values are not significantly different by sample (or by sample-related variables like cell population). We'll explore this visually below.

```{r, "lambda_plot"}
ggplot(meta_df, aes(x = Cell.Population, y = lambda_bs_conv_eff)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point()
```

## Relationship between Methylation Fractions across Cytosine Context, by Cell Population

Next, we'll explore if average methylation rate for each cytosine context correlates with that of other contexts across sample. For example, is a sample with highly methylated CpGs likely to have highly methylated CHGs (the first plot)?

We observe a few interesting facts; first, there is a visibly obvious correlation between average methylation rates of different cytosine contexts by sample. This is highly pronounced between CpH contexts (CHG vs. CHH). In each case, the relation appears roughly linear, though this is questionable for CpG vs. CHH context comparison. Another observation is that samples tend to cluster fairly well by cell population. Finally, for comparisons of CpG vs. CpH context, the strength of correlation between methylation rates varies significantly by cell type, with `MBPpos` and `TripleNeg` showing only weak correlation at best. 

```{r, "meth_frac_comparison_plots"}
#  Clean this up: code should be written around the idea we are plotting each
#  combination of methylation fractions (CpG, CHG, CHH), and plots should be
#  placed in a single grid

ggplot(meta_df, aes(x = perc_M_CpG, y = perc_M_CHG, color = Cell.Population)) +
    geom_point()

ggplot(meta_df, aes(x = perc_M_CpG, y = perc_M_CHH, color = Cell.Population)) +
    geom_point()

ggplot(meta_df, aes(x = perc_M_CHG, y = perc_M_CHH, color = Cell.Population)) +
    geom_point()
```

## Fraction of Covered Cytosines by Cell Population

Another useful piece of information is how well-covered the genome is with methylation information. Does coverage of cytosines vary by a sample's cell type?

```{r "coverage_fraction"}
#  The matrices in 'assays(bs_cpg)' and 'assays(bs_cph)' are stored on disk. To
#  speed up some below computations, we raise the per-block memory size
setAutoBlockSize(1e9)

#  Get the proportion of cytosines in each object (context) that have non-zero
#  coverage in at least one sample
meta_df$frac_covered_c_cpg <- DelayedArray::colMeans(assays(bs_cpg)$Cov > 3)
meta_df$frac_covered_c_cph <- DelayedArray::colMeans(assays(bs_cph)$Cov > 3)

#   Plot fraction of covered CpG-context cytosines by cell population
ggplot(meta_df, aes(x = Cell.Population, y = frac_covered_c_cpg)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(position = "jitter") +
    labs(title = "Fraction of covered cytosines in CpG context")

#   Plot fraction of covered CpH-context cytosines by cell population
ggplot(meta_df, aes(x = Cell.Population, y = frac_covered_c_cph)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(position = "jitter") +
    labs(title = "Fraction of covered cytosines in CpH context")
```

## Distribution of Methylation Fractions across Cytosines by Cell Population

Grouping together all samples of a particular cell type, we'll explore the methylation-fraction distribution across cytosines, separately for both CpG and CpH contexts.

For both cytosine contexts, we observe a bimodal distribution with peaks at fractions of 0 and 1. This suggests that within a particular sample, a cytosine site is disproportionately likely to have consistent methylation pattern. For example, many sites are such that all observations of the cytosine are methylated for a particular sample. Similarly, we don't see many sites where around half of the observed site are methylated for a given sample. It's also worth noting that the apparent bimodal form is likely not an artifact of low coverage-- i.e., only a small fraction of sites are covered just once or twice, a circumstance that would cause over-representation of the fractions of 0 or 1.

```{r "methylation_fractions"}
#   Randomly subset to a particular number of cytosines, to both control memory
#   and speed up plotting
max_sites <- 1000

#   Look at CpG sites first
indices <- sample(nrow(bs_cpg), max_sites)
m_frac <- assays(bs_cpg)$M[indices, ] / assays(bs_cpg)$Cov[indices, ]

#   It's worth looking at the distribution of coverage by site, since in theory
#   this could be cause for the bimodality observed in the plot below
table(assays(bs_cpg)$Cov[indices, ])

#   Form a data frame for easy plotting: we'll collapse methylation data for all
#   samples into a single column, 'm_frac'. Here 'LIBD.' denotes sample ID
meth_df <- data.frame(
    "m_frac" = as.numeric(m_frac),
    "LIBD." = rep(colnames(m_frac), each = max_sites)
)

#   Label each observation (methylation fraction for a particular cytosine) with
#   the cell population of the associated sample
meth_df$Cell.Population <- meta_df$Cell.Population[
    match(meth_df$"LIBD.", meta_df$"LIBD.")
]

ggplot(meth_df, aes(x = Cell.Population, y = m_frac)) +
    geom_violin() +
    labs(
        title = "Methylation-Fraction across CpG sites by Cell Population",
        y = "Methylation Fraction"
    )

#   Now look at CpH sites
indices <- sample(nrow(bs_cph), max_sites)
m_frac <- assays(bs_cph)$M[indices, ] / assays(bs_cph)$Cov[indices, ]

#   Again, we'll look at the distribution of coverage by site, since in theory
#   this could be cause for the bimodality observed in the plots below
table(assays(bs_cph)$Cov[indices, ])

#   Form a data frame for easy plotting: we'll collapse methylation data for all
#   samples into a single column, 'm_frac'. Here 'LIBD.' denotes sample ID
meth_df <- data.frame(
    "m_frac" = as.numeric(m_frac),
    "LIBD." = rep(colnames(m_frac), each = max_sites)
)

#   Label each observation (methylation fraction for a particular cytosine) with
#   the cell population of the associated sample
meth_df$Cell.Population <- meta_df$Cell.Population[
    match(meth_df$"LIBD.", meta_df$"LIBD.")
]

ggplot(meth_df, aes(x = Cell.Population, y = m_frac)) +
    geom_violin() +
    labs(
        title = "Methylation-Fraction across CpH sites by Cell Population",
        y = "Methylation Fraction"
    )
```

```{r compute_dmrs}
BiocParallel::register(BiocParallel::MulticoreParam(1))

cell_pop <- "SNAP25pos"

#   To avoid false positive DMRs, we'll subset to CpGs where at least 5 samples
#   in each group have at least two observations of the given CpG
num_cov_samples <- 5
num_cov_count <- 2

#   Subset object based on coverage requirements
bs_cov <- getCoverage(bs_cpg)
loci_to_keep <- which(
    rowSums(
        bs_cov[, bs_cpg$Cell.Population == cell_pop] >= num_cov_count
    ) >= num_cov_samples &
        rowSums(
            bs_cov[, bs_cpg$Cell.Population != cell_pop] >= num_cov_count
        ) >= num_cov_samples
)
length(loci_to_keep)

bs_cpg_sub <- bs_cpg[loci_to_keep, ]

#   Define the two cell-population-based groups used to compute t-statistics
group1 <- unique(bs_cpg_sub$"LIBD."[bs_cpg_sub$Cell.Population == cell_pop])
group2 <- unique(bs_cpg_sub$"LIBD."[bs_cpg_sub$Cell.Population != cell_pop])

#   Compute the t-stat and show the marginal distribution
cpg_t_stat <- BSmooth.tstat(
    bs_cpg_sub,
    group1 = group1, group2 = group2,
    estimate.var = "group2", local.correct = TRUE, verbose = TRUE
)
plot(cpg_t_stat)

#   Grab the genomic range associated with this particular cell population
if (cell_pop == "SNAP25pos") {
    gene_range <- GRanges("chr20:10172395-10308258")
} else if (cell_pop == "MBPpos") {
    gene_range <- GRanges("chr18:76978827-77133708")
} else if (cell_pop == "GAD1pos") {
    gene_range <- GRanges("chr2:170813210-170861151")
} else {
    stop(
        paste0("No gene associated with this cell population '", cell_pop, "'.")
    )
}

t_stat_df <- getStats(cpg_t_stat)

#   Filters for the upcoming DMRs: minimum magnitude of t-stat and min number of
#   base pairs, respectively
thres <- sd(t_stat_df[, "tstat.corrected"]) * 2.5
n_bases <- 3
abs_mean_diff <- 0.1

#   Compute DMRs and apply above filters
dmrs_orig <- dmrFinder(cpg_t_stat, cutoff = c(-1 * thres, thres))
dmrs <- subset(dmrs_orig, n >= n_bases & abs(meanDiff) >= abs_mean_diff)

#   Color plots by cell population group
p_data <- pData(bs_cpg_sub)
p_data$col <- ifelse(bs_cpg_sub$Cell.Population == cell_pop, "red", "blue")
pData(bs_cpg_sub) <- p_data

#   Plot the region around the gene associated with this particular cell
#   population
plotRegion(
    bs_cpg_sub, gene_range,
    extend = width(gene_range), addRegions = dmrs
)
```

Date the vignette was generated:

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette:

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information:

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# Bibliography

This vignette was generated using `r Biocpkg("BiocStyle")` `r Citep(bib[["BiocStyle"]])`
with `r CRANpkg("knitr")` `r Citep(bib[["knitr"]])` and `r CRANpkg("rmarkdown")` `r Citep(bib[["rmarkdown"]])` running behind the scenes.

Citations made with `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`.

```{r vignette_biblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
