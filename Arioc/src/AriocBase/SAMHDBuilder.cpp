/*
  SAMHDBuilder.cpp

    Copyright (c) 2015-2019 Johns Hopkins University.  All rights reserved.

    This file is part of the Arioc software distribution.  It is subject to the license terms
    in the LICENSE.txt file found in the top-level directory of the Arioc software distribution.
    The contents of this file, in whole or in part, may only be copied, modified, propagated, or
    redistributed in accordance with the license terms contained in LICENSE.txt.
*/
#include "stdafx.h"

#pragma region static variable definitions
const char* const SAMHDBuilder::m_samVersion = CONFIG_SAM_VERSION;

const char* const SAMHDBuilder::m_samAttributeOrder[AO1][AO2] =
                    { { "@HD", "VN", "SO", "GO", NULL },
                      { "@SQ", "SN", "LN", "AS", "M5", "SP", "UR", "rm", NULL },
                      { "@RG", "ID", "CN", "DS", "DT", "FO", "KS", "LB", "PG", "PI", "PL", "PU", "SM", NULL },
                      { "@PG", "ID", "fn", "PN", "CL", "PP", "DS", "VN", "dt", NULL },
                      { "@CO", NULL }
                    };

#pragma endregion

#pragma region constructors and destructor
/// [private] constructor
SAMHDBuilder::SAMHDBuilder()
{
    // (do not use this constructor)
}

/// [public] constructor
SAMHDBuilder::SAMHDBuilder( RGManager* prgm ) : m_prgm(prgm), m_docSAM(true),
                                                m_cmdTail(), m_appName(), m_appVersion(),   // (parentheses cause zero-initialization)
                                                m_suppressHD(false), m_suppressCfg(true),
                                                BigBucketThreshold()
{
}

/// [public] destructor
SAMHDBuilder::~SAMHDBuilder()
{
}
#pragma endregion

#pragma region private methods
/// [private] method verifyVN
void SAMHDBuilder::verifyVN( tinyxml2::XMLDocument* _pxd, char* _baseName )
{
    // verify the AriocE version (formatted as "<major>.<minor>")
    tinyxml2::XMLElement* pelPG = _pxd->RootElement()->FirstChildElement( "PG" );
    const char* sv = pelPG->Attribute( "VN" );
    char* pEnd;
    long lv = strtol( sv, &pEnd, 10 );
    bool vok = (lv >= MIN_ENCODER_VERSION_MAJOR);
    if( vok )
    {
        lv = strtol( pEnd+1, &pEnd, 10 );
        vok = (lv >= MIN_ENCODER_VERSION_MINOR);
    }

    if( !vok )
        throw new ApplicationException( __FILE__, __LINE__, "%s encoded with invalid AriocE v%s (v%d.%02d or later required)", _baseName, sv, MIN_ENCODER_VERSION_MAJOR, MIN_ENCODER_VERSION_MINOR );
}

/// [private] method addPG
void SAMHDBuilder::addPG( AriocAppMainBase* pamb )
{
    using namespace tinyxml2;

    // copy the application name and version strings
    strcpy_s( m_appName, sizeof m_appName, pamb->AppName );
    strcpy_s( m_appVersion, sizeof m_appVersion, pamb->AppVersion );

    // in the file name, replace double-quotes with the corresponding XML escape
    const char* pFrom = pamb->ConfigFileName;
    char* pTo = m_cmdTail;
    while( *pFrom )
    {
        // if the character is not a double-quote ...
        if( *pFrom != '"' )
        {
            // copy one character
            *(pTo++) = *(pFrom++);
            continue;
        }

        /* at this point we need to replace a double-quote with an escape */

        strcpy_s( pTo, 7, "&quot;" );
        pTo += 6;
        pFrom++ ;
    }
    *pTo = 0;

    // get the current system date and time as an ISO8601-formatted string
    TOD tod;
    char dt[20];
    sprintf_s( dt, sizeof dt, "%4u-%02u-%02uT%02u:%02u:%02u", tod.yr, tod.mo, tod.da, tod.hr, tod.mi, tod.se );

    /* At this point the XML document contains two <PG> elements generated by the AriocE application:
        - the PG element for the spaced-seed (nongapped) lookup tables
        - the PG element for the seed-and-extend (gapped) lookup tables
    */
    XMLElement* elSAM = m_docSAM.FirstChildElement( "SAM" );
    XMLElement* elPGg = elSAM->LastChildElement( "PG" );

    /* Build a new PG element for the Arioc application.  Although the input sequence data is presumably
        encoded by AriocE, there is no PP tag because there are multiple @PG IDs for AriocE. */
    XMLElement* elPG = m_docSAM.NewElement( "PG" );
    elPG->SetAttribute( "ID", m_appName );
    elPG->SetAttribute( "PN", m_appName );
    elPG->SetAttribute( "VN", m_appVersion );
    elPG->SetAttribute( "CL", m_cmdTail );
    elPG->SetAttribute( "dt", dt );

    // add the new PG element to the XML document
    elSAM->InsertAfterChild( elPGg, elPG );

    // update the HD element
    XMLElement* elHD = elSAM->FirstChildElement( "HD" );
    elHD->SetAttribute( "VN", m_samVersion );
    elHD->SetAttribute( "SO", "unsorted" );
    elHD->SetAttribute( "GO", "query" );    // (see SAMBuilderPaired::WriteRowPc and related functions)
}

/// [private] method addRG
void SAMHDBuilder::addRG( InputFileGroup* pifgQ )
{
    using namespace tinyxml2;

    /* For each input file...
        - we copy one or more read-group XML elements to the XML document that describes the SAM headers
        - we save a lookup table of read-group IDs that correspond to the read-group ordinal embedded
           in each .A21 row
    */
    for( UINT32 i=0; i<pifgQ->InputFile.n; ++i )
    {
        for( UINT32 n=0; n<m_prgm->OfsRG.n; ++n )
        {
            // make a local copy of the nth read group XML
            XMLDocument docRG;
            docRG.Parse( m_prgm->RG.p+m_prgm->OfsRG.p[n] );
            XMLElement* pelRGn = docRG.RootElement();
            if( pelRGn )
            {
                // make a local copy of the nth read group ID
                const char* IDn = pelRGn->Attribute( "ID" );

                // look for an RG element with a matching ID attribute in the SAM header document
                bool found = false;
                XMLElement* pelRG = m_docSAM.RootElement()->FirstChildElement( "RG" );
                while( pelRG )
                {
                    // if a matching ID attribute is found, set a flag and fall out of the loop
                    if( 0 == strcmp( pelRG->Attribute( "ID" ), IDn ) )
                    {
                        found = true;
                        break;
                    }

                    pelRG = pelRG->NextSiblingElement( "RG" );
                }

                if( found )
                {
                    // ensure that the remaining attribute values match
                    if( !SameXmlAttributes( pelRG, pelRGn ) )
                        throw new ApplicationException( __FILE__, __LINE__, "inconsistent read group attributes for ID='%s'", IDn );
                }
                else
                {
                    // add the read group info to the SAM header document
                    XMLNode* nodRG = pelRGn->ShallowClone( &m_docSAM );
                    m_docSAM.RootElement()->InsertEndChild( nodRG );
                }
            }
        }
    }
}

#pragma warning ( push )
#pragma warning( disable:4996 )     // (don't nag us about strcpy and _splitpath being "unsafe")

/// [private] method appendSAMtags
void SAMHDBuilder::appendSAMtags( char*& p, tinyxml2::XMLElement* pel )
{
    using namespace tinyxml2;

    // find the attribute order for the specified element
    INT32 ia1 = 0;
    for( ; ia1<AO1; ++ia1 )
    {
        if( 0 == strcmp( pel->Name(), m_samAttributeOrder[ia1][0]+1 ) )
            break;
    }

    // for elements not found in the attribute-order list, just append the attributes in the order they appear
    if( ia1 == AO1 )
    {
        const XMLAttribute* attr = pel->FirstAttribute();
        while( attr != NULL )
        {
            // SAM tags have 2-character names, so any other XML attributes (such as "subId") are ignored
            if( strlen(attr->Name()) == 2 )
            {
                // build a name-value pair
                *(p++) = '\t';                  // separate SAM tags with a tab character
                strcpy( p, attr->Name() );      // tag name
                p += strlen( attr->Name() );
                *(p++) = ':';                   // separate tag name and value with a colon
                                                // (there's no type specifier here; the SAM spec is silent regarding whether it should appear for user-defined tags)
                strcpy( p, attr->Value() );     // tag value
                p += strlen( attr->Value() );
            }

            // iterate
            attr = attr->Next();
        }

        return;
    }

    // traverse the list of possible attributes for the SAM header row
    for( INT32 ia2=1; ia2<AO2; ++ia2 )
    {
        const char* attrName = m_samAttributeOrder[ia1][ia2];
        if( attrName == NULL )
            break;

        // get the attribute value (if any)
        const char* pValue = pel->Attribute( attrName );
        if( pValue )
        {
            // build a name-value pair
            *(p++) = '\t';                  // separate SAM tags with a tab character

            strcpy( p, attrName );          // tag name
            p += strlen( attrName );
            *(p++) = ':';                   // separate tag name and value with a colon
                                            // (there's no type specifier here; the SAM spec is silent regarding whether it should appear for user-defined tags)
            strcpy( p, pValue );            // tag value
            p += strlen( pValue );
        }
    }
}

/// [private] method buildSAMheader
void SAMHDBuilder::buildSAMheader()
{
    using namespace tinyxml2;

    // allocate a big buffer to contain the SAM header; we will adjust the buffer size later
    m_SAMheader.Realloc( HEADER_BUFFER_SIZE, false );
    char* p = m_SAMheader.p;

    /* Traverse the XML document to build the SAM header:
        - elements (HD, SQ, etc.) become SAM record-type codes
        - attributes (VN, SN, etc.) become SAM tag/value pairs
    */
    XMLElement* elSAM = m_docSAM.FirstChildElement( "SAM" );
    XMLElement* el = elSAM->FirstChildElement();
    while( el != NULL )
    {
        // SAM record type
        *(p++) = '@';
        strcpy( p, el->Name() );
        p += strlen( el->Name() );

        // SAM tags
        appendSAMtags( p, el );

        // terminate each line with a UNIX-style newline
        *(p++) = '\n';

        // iterate
        el = el->NextSiblingElement();
    }

    // adjust the buffer size
    m_SAMheader.Realloc( p-m_SAMheader.p, false );
}

/// [private] method getReferenceConfigFileSpec
void SAMHDBuilder::getReferenceConfigFileSpec( char* baseName, char* fileSpec, const char* pathCfg )
{
    // get the config filename from the rightmost component of the specified path
    strcpy_s( fileSpec, FILENAME_MAX, pathCfg );

    // build the file specification for the .cfg file
    RaiiDirectory::ChopTrailingPathSeparator( fileSpec );   // remove any trailing separator
    char* p = fileSpec + strlen(fileSpec) - 1;              // point to the rightmost character in the path string

    // iterate backwards through the path until either a separator or the start of the string is encountered
    while( (p >= fileSpec) && (*p != '\\') && (*p != '/') )
        p-- ;
    p++ ;       // point to the first character of the rightmost component of the path (i.e., the base name)
    strcpy_s( baseName, BASENAME_MAX, p );                  // return a copy of the base name    
    
    RaiiDirectory::AppendTrailingPathSeparator( fileSpec ); // append a separator
    strcat_s( fileSpec, FILENAME_MAX, baseName );           // append the base name
    strcat_s( fileSpec, FILENAME_MAX, ".cfg" );             // append the file extension
}

/// [private] method getSN
void SAMHDBuilder::getSN( const char* _pathCfgN, const char* _pathCfgG )
{
    using namespace tinyxml2;

    XMLDocument docCfgN;
    XMLDocument docCfgG;

    // initialize an XML document using the configuration info for the nongapped lookup tables
    char fileSpecG[FILENAME_MAX];
    char baseNameG[BASENAME_MAX];
    getReferenceConfigFileSpec( baseNameG, fileSpecG, _pathCfgG );   // seed-and-extend (gapped) reference sequences
    LoadXmlFile( &docCfgG, fileSpecG );

    // do the same for the configuration info for the gapped LUTs
    char fileSpecN[FILENAME_MAX];
    char baseNameN[BASENAME_MAX];
    getReferenceConfigFileSpec( baseNameN, fileSpecN, _pathCfgN );   // spaced-seed (nongapped) reference sequences
    LoadXmlFile( &docCfgN, fileSpecN );

    // find the maximum nongapped R subId and count the number of nongapped R subId values
    INT32 maxSubIdN = -1;
    INT32 nSubIdN = 0;
    XMLElement* elSAM = docCfgN.RootElement();
    XMLElement* elSQ = elSAM->FirstChildElement( "SQ" );
    while( elSQ )
    {
        const char* sSubId = elSQ->Attribute( "subId" );
        if( sSubId == NULL )
            throw new ApplicationException( __FILE__, __LINE__, "Missing subId in %s", fileSpecN );

        INT32 subId = strtol( sSubId, NULL, 10 );
        if( subId > maxSubIdN )
            maxSubIdN = subId;
        ++nSubIdN;

        elSQ = elSQ->NextSiblingElement( "SQ" );
    }

    // do the same for the gapped R subId values
    INT32 maxSubIdG = -1;
    INT32 nSubIdG = 0;
    elSAM = docCfgG.RootElement();
    elSQ = elSAM->FirstChildElement( "SQ" );
    while( elSQ )
    {
        const char* sSubId = elSQ->Attribute( "subId" );
        if( sSubId == NULL )
            throw new ApplicationException( __FILE__, __LINE__, "Missing subId in %s", fileSpecG );

        INT32 subId = strtol( sSubId, NULL, 10 );
        if( subId > maxSubIdG )
            maxSubIdG = subId;
        ++nSubIdG;

        elSQ = elSQ->NextSiblingElement( "SQ" );
    }

    // sanity checks
    if( nSubIdG != nSubIdN )
        throw new ApplicationException( __FILE__, __LINE__, "Mismatched reference sequence count: %d nongapped != %d gapped", nSubIdN, nSubIdG );
    if( maxSubIdG != maxSubIdN )
        throw new ApplicationException( __FILE__, __LINE__, "Mismatched reference sequence subIds: %d nongapped != %d gapped", maxSubIdN, maxSubIdG );

    /* Build a list of SN strings for the nongapped R subIds.
    
       Each string is counted and tab-terminated:

            byte 0:      cch (number of characters in the string)
            byte 1..cch: string
            byte cch+1:  \t

        and the total number of bytes required is cch+2.
    */
    this->ofsSN.Realloc( maxSubIdN+1, true );
    elSAM = docCfgN.RootElement();
    elSQ = elSAM->FirstChildElement( "SQ" );
    while( elSQ )
    {
        INT32 subId = elSQ->IntAttribute( "subId" );
        const char* pSN = elSQ->Attribute( "SN" );
        if( pSN == NULL )
            throw new ApplicationException( __FILE__, __LINE__, "Missing sequence name (SN) for subId %d in nongapped reference configuration", subId );

        // get the string count byte
        UINT32 cch = static_cast<UINT32>(strlen( pSN ));
        if( cch > _UI8_MAX )
            throw new ApplicationException( __FILE__, __LINE__, "Invalid SN length: %u", cch );

        // save a copy of the sequence-name string
        UINT32 cbNewSN = cch + 2;
        this->SN.Realloc( this->SN.n+cbNewSN, true );
        char* p = this->SN.p + this->SN.n;
        *(p++) = static_cast<char>(cch);        // count
        strcpy_s( p, cbNewSN-1, pSN );          // null-terminated string

        // replace the trailing null byte with a tab character
        p[cch] = '\t';

        // save the offset of the counted SN string
        this->ofsSN.p[subId] = this->SN.n;

        // update the total number of bytes in the SN string buffer
        this->SN.n += cbNewSN;

        elSQ = elSQ->NextSiblingElement( "SQ" );
    }

    // verify that we have the same set of names for both gapped and nongapped reference subIds
    elSAM = docCfgG.RootElement();
    elSQ = elSAM->FirstChildElement( "SQ" );
    while( elSQ )
    {
        INT32 subId = elSQ->IntAttribute( "subId" );
        const char* pSNG = elSQ->Attribute( "SN" );
        if( pSNG == NULL )
            throw new ApplicationException( __FILE__, __LINE__, "Missing sequence name (SN) for subId %d in gapped reference configuration", subId );

        // sanity check
        char* pSNN = this->SN.p + this->ofsSN.p[subId];
        UINT8 cch = *reinterpret_cast<UINT8*>(pSNN);
        if( strncmp( pSNG, pSNN+1, cch ) )
        {
            pSNN++;
            pSNN[cch] = 0;
            throw new ApplicationException( __FILE__, __LINE__, "Sequence name mismatch for subId %d: nongapped='%s' gapped='%s'", subId, pSNN, pSNG );
        }

        elSQ = elSQ->NextSiblingElement( "SQ" );
    }
}
#pragma warning ( pop )
#pragma endregion

#pragma region public methods
/// [public] method Init
void SAMHDBuilder::Init( const char* pathCfgN, const char* pathCfgG, InputFileGroup* pifgQ, AriocAppMainBase* pamb )
{
    using namespace tinyxml2;

    XMLDocument* pdoc = NULL;

    try
    {
        // look for the Xparams that suppress SAM header output and SAM config file output
        INT32 i = pamb->Xparam.IndexOf( "SuppressSAMHeaders" );
        if( i >= 0 )
            m_suppressHD = (pamb->Xparam.Value(i) != 0 );
        i = pamb->Xparam.IndexOf( "SuppressSAMCfgFile" );
        if( i >= 0 )
            m_suppressCfg = (pamb->Xparam.Value(i) != 0 );

        // get SAM reference-sequence names (SN) from the configuration files
        getSN( pathCfgN, pathCfgG );

        // initialize an XML document using the configuration info for the nongapped lookup tables
        char fileSpec[FILENAME_MAX];
        char baseName[BASENAME_MAX];
        getReferenceConfigFileSpec( baseName, fileSpec, pathCfgN );     // spaced-seed (nongapped) lookup tables
        LoadXmlFile( &m_docSAM, fileSpec );
        verifyVN( &m_docSAM, baseName );

        // zap the fn attribute on the <SAM> element
        m_docSAM.RootElement()->DeleteAttribute( "fn" );

        // load configuration info for the gapped lookup tables
        getReferenceConfigFileSpec( baseName, fileSpec, pathCfgG );     // seed-and-extend (gapped) lookup tables
        XMLDocument* pdoc = new tinyxml2::XMLDocument;
        LoadXmlFile( pdoc, fileSpec );
        verifyVN( pdoc, baseName );

        // copy the PG info into this SAMHDBuilder's XML document
        XMLElement* pelPG = pdoc->RootElement()->FirstChildElement( "PG" );
        XMLNode* nodPG = pelPG->ShallowClone( &m_docSAM );
        m_docSAM.RootElement()->InsertEndChild( nodPG );

        // save the bucket-size threshold value used by the encoder for the seed-and-extend J lookup table
        const char* bbt = pelPG->Attribute( "mJ" );
        if( bbt )
            strcpy_s( this->BigBucketThreshold, sizeof this->BigBucketThreshold, bbt );

        delete pdoc;
        pdoc = NULL;

        // load configuration info for each of the encoded Q-sequence files
        for( UINT32 n=0; n<pifgQ->InputFile.n; ++n )
        {
            // replace "$a21.sbf" with ".cfg" in the A21 file specification
            strcpy_s( fileSpec, sizeof fileSpec, pifgQ->InputFile.p[n].Filespec );
            strcpy_s( fileSpec+strlen(fileSpec)-8, 5, ".cfg" );

            // load the XML document
            pdoc = new tinyxml2::XMLDocument;
            LoadXmlFile( pdoc, fileSpec );

            // copy the PG info into this SAMHDBuilder's XML document
            pelPG = pdoc->RootElement()->FirstChildElement( "PG" );
            nodPG = pelPG->ShallowClone( &m_docSAM );
            XMLElement* pelPGnew = reinterpret_cast<XMLElement*>(m_docSAM.RootElement()->InsertEndChild( nodPG ));

            delete pdoc;
            pdoc = NULL;

            /* The PGID tag must be unique within a SAM file, so we append a uniquifier as follows:
                - paired-end reads: <srcId>.<subId>p<mateId>
                - unpaired reads:   <srcId>.<subId>u<fileId>
            */
            char uniqueOrdinal[8];
            if( pifgQ->InputFile.p[n].IsPaired )
                sprintf_s( uniqueOrdinal, sizeof uniqueOrdinal, "p%u", pifgQ->InputFile.p[n].MateId+1 );
            else
                sprintf_s( uniqueOrdinal, sizeof uniqueOrdinal, "u%u", n );

            // append uniquifier to the PGID tag value
            char newPGID[FILENAME_MAX];
            sprintf_s( newPGID, sizeof newPGID,
                        "%s (%05d.%03u%s)",
                        pelPGnew->Attribute("ID"),
                        pifgQ->InputFile.p[n].SrcId, pifgQ->InputFile.p[n].SubId, uniqueOrdinal );
            pelPGnew->SetAttribute( "ID", newPGID );
        }

        // append a PG element for this application
        addPG( pamb );

#if TODO_CHOP_WHEN_DEBUGGED
        XMLPrinter lpt;
        m_docSAM.Print( &lpt );
        CDPrint( cdpCD0, "%s", __FUNCTION__ );
        OutputDebugString( lpt.CStr() );
#endif

        // append read group (RG) info
        addRG( pifgQ );

#if TODO_CHOP_WHEN_DEBUGGED
        XMLPrinter lpt;
        m_docSAM.Print( &lpt );
        CDPrint( cdpCD0, "%s", __FUNCTION__ );
        OutputDebugString( lpt.CStr() );
#endif

        // save the SAM-formatted header
        buildSAMheader();

#if TODO_CHOP_WHEN_DEBUGGED
        CDPrint( cdpCD0, __FUNCTION__ );
        OutputDebugString( m_SAMheader.p );
#endif
    }
    catch( ... )
    {
        if( pdoc )
            delete pdoc;
        throw;
    }
}

/// [public] method WriteHeader
void SAMHDBuilder::WriteHeader( RaiiFile& fileSAM )
{
    if( !m_suppressCfg )
    {
        // write SAM.cfg in the same directory as the first SAM file
        char cfgFileSpec[FILENAME_MAX] = { 0 };
        char driveLetter[_MAX_DRIVE] = { 0 };

#pragma warning ( push )
#pragma warning ( disable : 4996 )		// don't nag us about _splitpath and memcpy being "unsafe"
         // extract the drive letter (if any) and directory (with a trailing separator)
        _splitpath( fileSAM.FileSpec.p, driveLetter, cfgFileSpec, NULL, NULL );
        if( *driveLetter )
        {
            // slide the directory name over to make room for the drive letter
            size_t cch = strlen( driveLetter );
            memcpy( cfgFileSpec+cch, cfgFileSpec, strlen(cfgFileSpec)+1 );

            // insert the drive letter
            memcpy( cfgFileSpec, driveLetter, cch );
        }
#pragma warning ( pop )

        strcat_s( cfgFileSpec, FILENAME_MAX, "SAM.cfg" );                   // append the filename
        SaveXmlFile( cfgFileSpec, &m_docSAM );

        // set the flag so that we don't write the file more than once
        m_suppressCfg = true;
    }

    // write SAM header rows
    if( !m_suppressHD )
        fileSAM.Write( m_SAMheader.p, m_SAMheader.cb );
}
#pragma endregion
